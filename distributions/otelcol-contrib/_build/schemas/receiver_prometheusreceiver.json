{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "properties": {
    "api_server": {
      "description": "APIServer has the settings to enable the receiver to host the Prometheus API server in agent mode. This allows the user to call the endpoint to get the config, service discovery, and targets for debugging purposes.",
      "properties": {
        "enabled": {
          "type": "boolean"
        },
        "server_config": {
          "properties": {
            "auth": {
              "description": "Auth for this receiver",
              "properties": {
                "authenticator": {
                  "description": "AuthenticatorID specifies the name of the extension to use in order to authenticate the incoming data point.",
                  "type": "object"
                },
                "request_params": {
                  "description": "RequestParameters is a list of parameters that should be extracted from the request and added to the context. When a parameter is found in both the query string and the header, the value from the query string will be used.",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                }
              },
              "type": "object"
            },
            "compression_algorithms": {
              "description": "CompressionAlgorithms configures the list of compression algorithms the server can accept. Default: [\"\", \"gzip\", \"zstd\", \"zlib\", \"snappy\", \"deflate\"]",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "cors": {
              "description": "CORS configures the server for HTTP cross-origin resource sharing (CORS).",
              "properties": {
                "allowed_headers": {
                  "description": "AllowedHeaders sets what headers will be allowed in CORS requests. The Accept, Accept-Language, Content-Type, and Content-Language headers are implicitly allowed. If no headers are listed, X-Requested-With will also be accepted by default. Include \"*\" to allow any request header.",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "allowed_origins": {
                  "description": "AllowedOrigins sets the allowed values of the Origin header for HTTP/JSON requests to an OTLP receiver. An origin may contain a wildcard (*) to replace 0 or more characters (e.g., \"http://*.domain.com\", or \"*\" to allow any origin).",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "max_age": {
                  "description": "MaxAge sets the value of the Access-Control-Max-Age response header. Set it to the number of seconds that browsers should cache a CORS preflight response for.",
                  "type": "integer"
                }
              },
              "type": "object"
            },
            "endpoint": {
              "description": "Endpoint configures the listening address for the server.",
              "type": "string"
            },
            "idle_timeout": {
              "description": "IdleTimeout is the maximum amount of time to wait for the next request when keep-alives are enabled. If IdleTimeout is zero, the value of ReadTimeout is used. If both are zero, there is no timeout.",
              "pattern": "^[0-9]+(ns|us|µs|ms|s|m|h)$",
              "type": "string"
            },
            "include_metadata": {
              "description": "IncludeMetadata propagates the client metadata from the incoming requests to the downstream consumers",
              "type": "boolean"
            },
            "keep_alives_enabled": {
              "description": "KeepAlivesEnabled controls whether HTTP keep-alives are enabled. By default, keep-alives are always enabled. Only very resource-constrained environments should disable them.",
              "type": "boolean"
            },
            "max_request_body_size": {
              "description": "MaxRequestBodySize sets the maximum request body size in bytes. Default: 20MiB.",
              "type": "integer"
            },
            "middlewares": {
              "description": "Middlewares are used to add custom functionality to the HTTP server. Middleware handlers are called in the order they appear in this list, with the first middleware becoming the outermost handler.",
              "items": {
                "properties": {
                  "id": {
                    "description": "ID specifies the name of the extension to use.",
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "type": "array"
            },
            "read_header_timeout": {
              "description": "ReadHeaderTimeout is the amount of time allowed to read request headers. The connection's read deadline is reset after reading the headers and the Handler can decide what is considered too slow for the body. If ReadHeaderTimeout is zero, the value of ReadTimeout is used. If both are zero, there is no timeout.",
              "pattern": "^[0-9]+(ns|us|µs|ms|s|m|h)$",
              "type": "string"
            },
            "read_timeout": {
              "description": "ReadTimeout is the maximum duration for reading the entire request, including the body. A zero or negative value means there will be no timeout. Because ReadTimeout does not let Handlers make per-request decisions on each request body's acceptable deadline or upload rate, most users will prefer to use ReadHeaderTimeout. It is valid to use them both.",
              "pattern": "^[0-9]+(ns|us|µs|ms|s|m|h)$",
              "type": "string"
            },
            "response_headers": {
              "description": "Additional headers attached to each HTTP response sent to the client. Header values are opaque since they may be sensitive.",
              "items": {
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "value": {
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "type": "array"
            },
            "tls": {
              "description": "TLS struct exposes TLS client configuration.",
              "properties": {
                "ca_file": {
                  "description": "Path to the CA cert. For a client this verifies the server certificate. For a server this verifies client certificates. If empty uses system root CA. (optional)",
                  "type": "string"
                },
                "ca_pem": {
                  "description": "In memory PEM encoded cert. (optional)",
                  "type": "string"
                },
                "cert_file": {
                  "description": "Path to the TLS cert to use for TLS required connections. (optional)",
                  "type": "string"
                },
                "cert_pem": {
                  "description": "In memory PEM encoded TLS cert to use for TLS required connections. (optional)",
                  "type": "string"
                },
                "cipher_suites": {
                  "description": "CipherSuites is a list of TLS cipher suites that the TLS transport can use. If left blank, a safe default list is used. See https://go.dev/src/crypto/tls/cipher_suites.go for a list of supported cipher suites.",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "client_ca_file": {
                  "description": "Path to the TLS cert to use by the server to verify a client certificate. (optional) This sets the ClientCAs and ClientAuth to RequireAndVerifyClientCert in the TLSConfig. Please refer to https://godoc.org/crypto/tls#Config for more information. (optional)",
                  "type": "string"
                },
                "client_ca_file_reload": {
                  "description": "Reload the ClientCAs file when it is modified (optional, default false)",
                  "type": "boolean"
                },
                "curve_preferences": {
                  "description": "contains the elliptic curves that will be used in an ECDHE handshake, in preference order Defaults to empty list and \"crypto/tls\" defaults are used, internally.",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "include_system_ca_certs_pool": {
                  "description": "If true, load system CA certificates pool in addition to the certificates configured in this struct.",
                  "type": "boolean"
                },
                "key_file": {
                  "description": "Path to the TLS key to use for TLS required connections. (optional)",
                  "type": "string"
                },
                "key_pem": {
                  "description": "In memory PEM encoded TLS key to use for TLS required connections. (optional)",
                  "type": "string"
                },
                "max_version": {
                  "description": "MaxVersion sets the maximum TLS version that is acceptable. If not set, refer to crypto/tls for defaults. (optional)",
                  "type": "string"
                },
                "min_version": {
                  "description": "MinVersion sets the minimum TLS version that is acceptable. If not set, TLS 1.2 will be used. (optional)",
                  "type": "string"
                },
                "reload_interval": {
                  "description": "ReloadInterval specifies the duration after which the certificate will be reloaded If not set, it will never be reloaded (optional)",
                  "pattern": "^[0-9]+(ns|us|µs|ms|s|m|h)$",
                  "type": "string"
                },
                "tpm": {
                  "description": "Trusted platform module configuration",
                  "properties": {
                    "auth": {
                      "type": "string"
                    },
                    "enabled": {
                      "type": "boolean"
                    },
                    "owner_auth": {
                      "type": "string"
                    },
                    "path": {
                      "description": "The path to the TPM device or Unix domain socket. For instance /dev/tpm0 or /dev/tpmrm0.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              },
              "type": "object"
            },
            "write_timeout": {
              "description": "WriteTimeout is the maximum duration before timing out writes of the response. It is reset whenever a new request's header is read. Like ReadTimeout, it does not let Handlers make decisions on a per-request basis. A zero or negative value means there will be no timeout.",
              "pattern": "^[0-9]+(ns|us|µs|ms|s|m|h)$",
              "type": "string"
            }
          },
          "type": "object"
        }
      },
      "type": "object"
    },
    "config": {
      "properties": {
        "alertingconfig": {
          "properties": {
            "alertmanagerconfigs": {
              "items": {
                "properties": {
                  "alertrelabelconfigs": {
                    "description": "Relabel alerts before sending to the specific alertmanager.",
                    "items": {
                      "properties": {
                        "action": {
                          "description": "Action is the action to be performed for the relabeling.",
                          "type": "string"
                        },
                        "modulus": {
                          "description": "Modulus to take of the hash of concatenated values from the source labels.",
                          "type": "integer"
                        },
                        "namevalidationscheme": {
                          "description": "NameValidationScheme to use when validating labels.",
                          "type": "integer"
                        },
                        "regex": {
                          "description": "Regex against which the concatenation is matched.",
                          "type": "object"
                        },
                        "replacement": {
                          "description": "Replacement is the regex replacement pattern to be used.",
                          "type": "string"
                        },
                        "separator": {
                          "description": "Separator is the string between concatenated values from the source labels.",
                          "type": "string"
                        },
                        "sourceLabels": {
                          "description": "A list of labels from which values are taken and concatenated with the configured separator in order.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "targetLabel": {
                          "description": "TargetLabel is the label to which the resulting string is written in a replacement. Regexp interpolation is allowed for the replace action.",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "type": "array"
                  },
                  "apiversion": {
                    "description": "The api version of Alertmanager.",
                    "type": "string"
                  },
                  "httpclientconfig": {
                    "properties": {
                      "authorization": {
                        "description": "The HTTP authorization credentials for the targets.",
                        "properties": {
                          "credentials": {
                            "type": "string"
                          },
                          "credentials_file": {
                            "type": "string"
                          },
                          "credentials_ref": {
                            "description": "CredentialsRef is the name of the secret within the secret manager to use as credentials.",
                            "type": "string"
                          },
                          "type": {
                            "type": "string"
                          }
                        },
                        "type": "object"
                      },
                      "basic_auth": {
                        "description": "The HTTP basic authentication credentials for the targets.",
                        "properties": {
                          "password": {
                            "type": "string"
                          },
                          "password_file": {
                            "type": "string"
                          },
                          "password_ref": {
                            "description": "PasswordRef is the name of the secret within the secret manager to use as the password.",
                            "type": "string"
                          },
                          "username": {
                            "type": "string"
                          },
                          "username_file": {
                            "type": "string"
                          },
                          "username_ref": {
                            "description": "UsernameRef is the name of the secret within the secret manager to use as the username.",
                            "type": "string"
                          }
                        },
                        "type": "object"
                      },
                      "bearer_token": {
                        "deprecated": true,
                        "description": "The bearer token for the targets. Deprecated in favour of Authorization.Credentials.",
                        "type": "string"
                      },
                      "bearer_token_file": {
                        "deprecated": true,
                        "description": "The bearer token file for the targets. Deprecated in favour of Authorization.CredentialsFile.",
                        "type": "string"
                      },
                      "enable_http2": {
                        "description": "EnableHTTP2 specifies whether the client should configure HTTP2. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.",
                        "type": "boolean"
                      },
                      "follow_redirects": {
                        "description": "FollowRedirects specifies whether the client should follow HTTP 3xx redirects. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.",
                        "type": "boolean"
                      },
                      "http_headers": {
                        "description": "HTTPHeaders specify headers to inject in the requests. Those headers could be marshalled back to the users.",
                        "properties": {
                          "headers": {
                            "additionalProperties": {
                              "properties": {
                                "files": {
                                  "items": {
                                    "type": "string"
                                  },
                                  "type": "array"
                                },
                                "secrets": {
                                  "items": {
                                    "type": "string"
                                  },
                                  "type": "array"
                                },
                                "values": {
                                  "items": {
                                    "type": "string"
                                  },
                                  "type": "array"
                                }
                              },
                              "type": "object"
                            },
                            "type": "object"
                          }
                        },
                        "type": "object"
                      },
                      "no_proxy": {
                        "description": "NoProxy contains addresses that should not use a proxy.",
                        "type": "string"
                      },
                      "oauth2": {
                        "description": "The OAuth2 client credentials used to fetch a token for the targets.",
                        "properties": {
                          "audience": {
                            "description": "Audience optionally specifies the intended audience of the request.  If empty, the value of TokenURL is used as the intended audience. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                            "type": "string"
                          },
                          "claims": {
                            "additionalProperties": {
                              "additionalProperties": true,
                              "type": "object"
                            },
                            "description": "Claims is a map of claims to be added to the JWT token. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                            "type": "object"
                          },
                          "client_certificate_key": {
                            "type": "string"
                          },
                          "client_certificate_key_file": {
                            "type": "string"
                          },
                          "client_certificate_key_id": {
                            "type": "string"
                          },
                          "client_certificate_key_ref": {
                            "description": "ClientCertificateKeyRef is the name of the secret within the secret manager to use as the client secret.",
                            "type": "string"
                          },
                          "client_id": {
                            "type": "string"
                          },
                          "client_secret": {
                            "type": "string"
                          },
                          "client_secret_file": {
                            "type": "string"
                          },
                          "client_secret_ref": {
                            "description": "ClientSecretRef is the name of the secret within the secret manager to use as the client secret.",
                            "type": "string"
                          },
                          "endpoint_params": {
                            "additionalProperties": {
                              "type": "string"
                            },
                            "type": "object"
                          },
                          "grant_type": {
                            "description": "GrantType is the OAuth2 grant type to use. It can be one of \"client_credentials\" or \"urn:ietf:params:oauth:grant-type:jwt-bearer\" (RFC 7523). Default value is \"client_credentials\"",
                            "type": "string"
                          },
                          "iss": {
                            "description": "Iss is the OAuth client identifier used when communicating with the configured OAuth provider. Default value is client_id. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                            "type": "string"
                          },
                          "no_proxy": {
                            "description": "NoProxy contains addresses that should not use a proxy.",
                            "type": "string"
                          },
                          "proxy_connect_header": {
                            "additionalProperties": {
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "description": "ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. Assume that at least _some_ of these headers are going to contain secrets and use Secret as the value type instead of string.",
                            "type": "object"
                          },
                          "proxy_from_environment": {
                            "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.",
                            "type": "boolean"
                          },
                          "proxy_url": {
                            "description": "HTTP proxy server to use to connect to the targets.",
                            "properties": {
                              "forcequery": {
                                "description": "append a query ('?') even if RawQuery is empty",
                                "type": "boolean"
                              },
                              "fragment": {
                                "description": "fragment for references, without '#'",
                                "type": "string"
                              },
                              "host": {
                                "description": "host or host:port (see Hostname and Port methods)",
                                "type": "string"
                              },
                              "omithost": {
                                "description": "do not emit empty host (authority)",
                                "type": "boolean"
                              },
                              "opaque": {
                                "description": "encoded opaque data",
                                "type": "string"
                              },
                              "path": {
                                "description": "path (relative paths may omit leading slash)",
                                "type": "string"
                              },
                              "rawfragment": {
                                "description": "encoded fragment hint (see EscapedFragment method)",
                                "type": "string"
                              },
                              "rawpath": {
                                "description": "encoded path hint (see EscapedPath method)",
                                "type": "string"
                              },
                              "rawquery": {
                                "description": "encoded query values, without '?'",
                                "type": "string"
                              },
                              "scheme": {
                                "type": "string"
                              },
                              "user": {
                                "description": "username and password information",
                                "type": "object"
                              }
                            },
                            "type": "object"
                          },
                          "scopes": {
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "signature_algorithm": {
                            "description": "SignatureAlgorithm is the RSA algorithm used to sign JWT token. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\". Default value is RS256 and valid values RS256, RS384, RS512",
                            "type": "string"
                          },
                          "tlsconfig": {
                            "properties": {
                              "ca": {
                                "description": "Text of the CA cert to use for the targets.",
                                "type": "string"
                              },
                              "ca_file": {
                                "description": "The CA cert to use for the targets.",
                                "type": "string"
                              },
                              "ca_ref": {
                                "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                                "type": "string"
                              },
                              "cert": {
                                "description": "Text of the client cert file for the targets.",
                                "type": "string"
                              },
                              "cert_file": {
                                "description": "The client cert file for the targets.",
                                "type": "string"
                              },
                              "cert_ref": {
                                "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                                "type": "string"
                              },
                              "insecure_skip_verify": {
                                "description": "Disable target certificate validation.",
                                "type": "boolean"
                              },
                              "key": {
                                "description": "Text of the client key file for the targets.",
                                "type": "string"
                              },
                              "key_file": {
                                "description": "The client key file for the targets.",
                                "type": "string"
                              },
                              "key_ref": {
                                "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                                "type": "string"
                              },
                              "max_version": {
                                "description": "Maximum TLS version.",
                                "type": "integer"
                              },
                              "min_version": {
                                "description": "Minimum TLS version.",
                                "type": "integer"
                              },
                              "server_name": {
                                "description": "Used to verify the hostname for the targets.",
                                "type": "string"
                              }
                            },
                            "type": "object"
                          },
                          "token_url": {
                            "type": "string"
                          }
                        },
                        "type": "object"
                      },
                      "proxy_connect_header": {
                        "additionalProperties": {
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "description": "ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. Assume that at least _some_ of these headers are going to contain secrets and use Secret as the value type instead of string.",
                        "type": "object"
                      },
                      "proxy_from_environment": {
                        "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.",
                        "type": "boolean"
                      },
                      "proxy_url": {
                        "description": "HTTP proxy server to use to connect to the targets.",
                        "properties": {
                          "forcequery": {
                            "description": "append a query ('?') even if RawQuery is empty",
                            "type": "boolean"
                          },
                          "fragment": {
                            "description": "fragment for references, without '#'",
                            "type": "string"
                          },
                          "host": {
                            "description": "host or host:port (see Hostname and Port methods)",
                            "type": "string"
                          },
                          "omithost": {
                            "description": "do not emit empty host (authority)",
                            "type": "boolean"
                          },
                          "opaque": {
                            "description": "encoded opaque data",
                            "type": "string"
                          },
                          "path": {
                            "description": "path (relative paths may omit leading slash)",
                            "type": "string"
                          },
                          "rawfragment": {
                            "description": "encoded fragment hint (see EscapedFragment method)",
                            "type": "string"
                          },
                          "rawpath": {
                            "description": "encoded path hint (see EscapedPath method)",
                            "type": "string"
                          },
                          "rawquery": {
                            "description": "encoded query values, without '?'",
                            "type": "string"
                          },
                          "scheme": {
                            "type": "string"
                          },
                          "user": {
                            "description": "username and password information",
                            "type": "object"
                          }
                        },
                        "type": "object"
                      },
                      "tls_config": {
                        "description": "TLSConfig to use to connect to the targets.",
                        "properties": {
                          "ca": {
                            "description": "Text of the CA cert to use for the targets.",
                            "type": "string"
                          },
                          "ca_file": {
                            "description": "The CA cert to use for the targets.",
                            "type": "string"
                          },
                          "ca_ref": {
                            "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                            "type": "string"
                          },
                          "cert": {
                            "description": "Text of the client cert file for the targets.",
                            "type": "string"
                          },
                          "cert_file": {
                            "description": "The client cert file for the targets.",
                            "type": "string"
                          },
                          "cert_ref": {
                            "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                            "type": "string"
                          },
                          "insecure_skip_verify": {
                            "description": "Disable target certificate validation.",
                            "type": "boolean"
                          },
                          "key": {
                            "description": "Text of the client key file for the targets.",
                            "type": "string"
                          },
                          "key_file": {
                            "description": "The client key file for the targets.",
                            "type": "string"
                          },
                          "key_ref": {
                            "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                            "type": "string"
                          },
                          "max_version": {
                            "description": "Maximum TLS version.",
                            "type": "integer"
                          },
                          "min_version": {
                            "description": "Minimum TLS version.",
                            "type": "integer"
                          },
                          "server_name": {
                            "description": "Used to verify the hostname for the targets.",
                            "type": "string"
                          }
                        },
                        "type": "object"
                      }
                    },
                    "type": "object"
                  },
                  "pathprefix": {
                    "description": "Path prefix to add in front of the push endpoint path.",
                    "type": "string"
                  },
                  "relabelconfigs": {
                    "description": "List of Alertmanager relabel configurations.",
                    "items": {
                      "properties": {
                        "action": {
                          "description": "Action is the action to be performed for the relabeling.",
                          "type": "string"
                        },
                        "modulus": {
                          "description": "Modulus to take of the hash of concatenated values from the source labels.",
                          "type": "integer"
                        },
                        "namevalidationscheme": {
                          "description": "NameValidationScheme to use when validating labels.",
                          "type": "integer"
                        },
                        "regex": {
                          "description": "Regex against which the concatenation is matched.",
                          "type": "object"
                        },
                        "replacement": {
                          "description": "Replacement is the regex replacement pattern to be used.",
                          "type": "string"
                        },
                        "separator": {
                          "description": "Separator is the string between concatenated values from the source labels.",
                          "type": "string"
                        },
                        "sourceLabels": {
                          "description": "A list of labels from which values are taken and concatenated with the configured separator in order.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "targetLabel": {
                          "description": "TargetLabel is the label to which the resulting string is written in a replacement. Regexp interpolation is allowed for the replace action.",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "type": "array"
                  },
                  "scheme": {
                    "description": "The URL scheme to use when talking to Alertmanagers.",
                    "type": "string"
                  },
                  "servicediscoveryconfigs": {
                    "items": {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    "type": "array"
                  },
                  "sigv4config": {
                    "properties": {
                      "accesskey": {
                        "type": "string"
                      },
                      "profile": {
                        "type": "string"
                      },
                      "region": {
                        "type": "string"
                      },
                      "rolearn": {
                        "type": "string"
                      },
                      "secretkey": {
                        "type": "string"
                      },
                      "servicename": {
                        "type": "string"
                      },
                      "usefipsstsendpoint": {
                        "type": "boolean"
                      }
                    },
                    "type": "object"
                  },
                  "timeout": {
                    "description": "The timeout used when sending alerts.",
                    "type": "integer"
                  }
                },
                "type": "object"
              },
              "type": "array"
            },
            "alertrelabelconfigs": {
              "items": {
                "properties": {
                  "action": {
                    "description": "Action is the action to be performed for the relabeling.",
                    "type": "string"
                  },
                  "modulus": {
                    "description": "Modulus to take of the hash of concatenated values from the source labels.",
                    "type": "integer"
                  },
                  "namevalidationscheme": {
                    "description": "NameValidationScheme to use when validating labels.",
                    "type": "integer"
                  },
                  "regex": {
                    "description": "Regex against which the concatenation is matched.",
                    "type": "object"
                  },
                  "replacement": {
                    "description": "Replacement is the regex replacement pattern to be used.",
                    "type": "string"
                  },
                  "separator": {
                    "description": "Separator is the string between concatenated values from the source labels.",
                    "type": "string"
                  },
                  "sourceLabels": {
                    "description": "A list of labels from which values are taken and concatenated with the configured separator in order.",
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "targetLabel": {
                    "description": "TargetLabel is the label to which the resulting string is written in a replacement. Regexp interpolation is allowed for the replace action.",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "type": "array"
            }
          },
          "type": "object"
        },
        "globalconfig": {
          "properties": {
            "alwaysscrapeclassichistograms": {
              "description": "Whether to scrape a classic histogram, even if it is also exposed as a native histogram.",
              "type": "boolean"
            },
            "bodysizelimit": {
              "description": "An uncompressed response body larger than this many bytes will cause the scrape to fail. 0 means no limit.",
              "type": "integer"
            },
            "convertclassichistogramstonhcb": {
              "description": "Whether to convert all scraped classic histograms into native histograms with custom buckets.",
              "type": "boolean"
            },
            "evaluationinterval": {
              "description": "How frequently to evaluate rules by default.",
              "type": "integer"
            },
            "externallabels": {
              "description": "The labels to add to any timeseries that this Prometheus instance scrapes.",
              "type": "object"
            },
            "keepdroppedtargets": {
              "description": "Keep no more than this many dropped targets per job. 0 means no limit.",
              "type": "integer"
            },
            "labellimit": {
              "description": "More than this many labels post metric-relabeling will cause the scrape to fail. 0 means no limit.",
              "type": "integer"
            },
            "labelnamelengthlimit": {
              "description": "More than this label name length post metric-relabeling will cause the scrape to fail. 0 means no limit.",
              "type": "integer"
            },
            "labelvaluelengthlimit": {
              "description": "More than this label value length post metric-relabeling will cause the scrape to fail. 0 means no limit.",
              "type": "integer"
            },
            "metricnameescapingscheme": {
              "description": "Metric name escaping mode to request through content negotiation. Can be blank in config files but must have a value if a ScrapeConfig is created programmatically.",
              "type": "string"
            },
            "metricnamevalidationscheme": {
              "description": "Allow UTF8 Metric and Label Names. Can be blank in config files but must have a value if a GlobalConfig is created programmatically.",
              "type": "integer"
            },
            "querylogfile": {
              "description": "File to which PromQL queries are logged.",
              "type": "string"
            },
            "rulequeryoffset": {
              "description": "Offset the rule evaluation timestamp of this particular group by the specified duration into the past to ensure the underlying metrics have been received.",
              "type": "integer"
            },
            "samplelimit": {
              "description": "More than this many samples post metric-relabeling will cause the scrape to fail. 0 means no limit.",
              "type": "integer"
            },
            "scrapefailurelogfile": {
              "description": "File to which scrape failures are logged.",
              "type": "string"
            },
            "scrapeinterval": {
              "description": "How frequently to scrape targets by default.",
              "type": "integer"
            },
            "scrapeprotocols": {
              "description": "The protocols to negotiate during a scrape. It tells clients what protocol are accepted by Prometheus and with what weight (most wanted is first). Supported values (case sensitive): PrometheusProto, OpenMetricsText0.0.1, OpenMetricsText1.0.0, PrometheusText0.0.4.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "scrapetimeout": {
              "description": "The default timeout when scraping targets.",
              "type": "integer"
            },
            "targetlimit": {
              "description": "More than this many targets after the target relabeling will cause the scrapes to fail. 0 means no limit.",
              "type": "integer"
            }
          },
          "type": "object"
        },
        "otlpconfig": {
          "properties": {
            "converthistogramstonhcb": {
              "type": "boolean"
            },
            "ignoreresourceattributes": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "keepidentifyingresourceattributes": {
              "type": "boolean"
            },
            "promoteallresourceattributes": {
              "type": "boolean"
            },
            "promoteresourceattributes": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "promotescopemetadata": {
              "description": "PromoteScopeMetadata controls whether to promote OTel scope metadata (i.e. name, version, schema URL, and attributes) to metric labels. As per OTel spec, the aforementioned scope metadata should be identifying, i.e. made into metric labels.",
              "type": "boolean"
            },
            "translationstrategy": {
              "type": "string"
            }
          },
          "type": "object"
        },
        "remotereadconfigs": {
          "items": {
            "properties": {
              "chunkedreadlimit": {
                "type": "integer"
              },
              "filterexternallabels": {
                "description": "Whether to use the external labels as selectors for the remote read endpoint.",
                "type": "boolean"
              },
              "headers": {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              "httpclientconfig": {
                "description": "We cannot do proper Go type embedding below as the parser will then parse values arbitrarily into the overflow maps of further-down types.",
                "properties": {
                  "authorization": {
                    "description": "The HTTP authorization credentials for the targets.",
                    "properties": {
                      "credentials": {
                        "type": "string"
                      },
                      "credentials_file": {
                        "type": "string"
                      },
                      "credentials_ref": {
                        "description": "CredentialsRef is the name of the secret within the secret manager to use as credentials.",
                        "type": "string"
                      },
                      "type": {
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "basic_auth": {
                    "description": "The HTTP basic authentication credentials for the targets.",
                    "properties": {
                      "password": {
                        "type": "string"
                      },
                      "password_file": {
                        "type": "string"
                      },
                      "password_ref": {
                        "description": "PasswordRef is the name of the secret within the secret manager to use as the password.",
                        "type": "string"
                      },
                      "username": {
                        "type": "string"
                      },
                      "username_file": {
                        "type": "string"
                      },
                      "username_ref": {
                        "description": "UsernameRef is the name of the secret within the secret manager to use as the username.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "bearer_token": {
                    "deprecated": true,
                    "description": "The bearer token for the targets. Deprecated in favour of Authorization.Credentials.",
                    "type": "string"
                  },
                  "bearer_token_file": {
                    "deprecated": true,
                    "description": "The bearer token file for the targets. Deprecated in favour of Authorization.CredentialsFile.",
                    "type": "string"
                  },
                  "enable_http2": {
                    "description": "EnableHTTP2 specifies whether the client should configure HTTP2. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.",
                    "type": "boolean"
                  },
                  "follow_redirects": {
                    "description": "FollowRedirects specifies whether the client should follow HTTP 3xx redirects. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.",
                    "type": "boolean"
                  },
                  "http_headers": {
                    "description": "HTTPHeaders specify headers to inject in the requests. Those headers could be marshalled back to the users.",
                    "properties": {
                      "headers": {
                        "additionalProperties": {
                          "properties": {
                            "files": {
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "secrets": {
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "values": {
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            }
                          },
                          "type": "object"
                        },
                        "type": "object"
                      }
                    },
                    "type": "object"
                  },
                  "no_proxy": {
                    "description": "NoProxy contains addresses that should not use a proxy.",
                    "type": "string"
                  },
                  "oauth2": {
                    "description": "The OAuth2 client credentials used to fetch a token for the targets.",
                    "properties": {
                      "audience": {
                        "description": "Audience optionally specifies the intended audience of the request.  If empty, the value of TokenURL is used as the intended audience. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                        "type": "string"
                      },
                      "claims": {
                        "additionalProperties": {
                          "additionalProperties": true,
                          "type": "object"
                        },
                        "description": "Claims is a map of claims to be added to the JWT token. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                        "type": "object"
                      },
                      "client_certificate_key": {
                        "type": "string"
                      },
                      "client_certificate_key_file": {
                        "type": "string"
                      },
                      "client_certificate_key_id": {
                        "type": "string"
                      },
                      "client_certificate_key_ref": {
                        "description": "ClientCertificateKeyRef is the name of the secret within the secret manager to use as the client secret.",
                        "type": "string"
                      },
                      "client_id": {
                        "type": "string"
                      },
                      "client_secret": {
                        "type": "string"
                      },
                      "client_secret_file": {
                        "type": "string"
                      },
                      "client_secret_ref": {
                        "description": "ClientSecretRef is the name of the secret within the secret manager to use as the client secret.",
                        "type": "string"
                      },
                      "endpoint_params": {
                        "additionalProperties": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "grant_type": {
                        "description": "GrantType is the OAuth2 grant type to use. It can be one of \"client_credentials\" or \"urn:ietf:params:oauth:grant-type:jwt-bearer\" (RFC 7523). Default value is \"client_credentials\"",
                        "type": "string"
                      },
                      "iss": {
                        "description": "Iss is the OAuth client identifier used when communicating with the configured OAuth provider. Default value is client_id. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                        "type": "string"
                      },
                      "no_proxy": {
                        "description": "NoProxy contains addresses that should not use a proxy.",
                        "type": "string"
                      },
                      "proxy_connect_header": {
                        "additionalProperties": {
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "description": "ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. Assume that at least _some_ of these headers are going to contain secrets and use Secret as the value type instead of string.",
                        "type": "object"
                      },
                      "proxy_from_environment": {
                        "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.",
                        "type": "boolean"
                      },
                      "proxy_url": {
                        "description": "HTTP proxy server to use to connect to the targets.",
                        "properties": {
                          "forcequery": {
                            "description": "append a query ('?') even if RawQuery is empty",
                            "type": "boolean"
                          },
                          "fragment": {
                            "description": "fragment for references, without '#'",
                            "type": "string"
                          },
                          "host": {
                            "description": "host or host:port (see Hostname and Port methods)",
                            "type": "string"
                          },
                          "omithost": {
                            "description": "do not emit empty host (authority)",
                            "type": "boolean"
                          },
                          "opaque": {
                            "description": "encoded opaque data",
                            "type": "string"
                          },
                          "path": {
                            "description": "path (relative paths may omit leading slash)",
                            "type": "string"
                          },
                          "rawfragment": {
                            "description": "encoded fragment hint (see EscapedFragment method)",
                            "type": "string"
                          },
                          "rawpath": {
                            "description": "encoded path hint (see EscapedPath method)",
                            "type": "string"
                          },
                          "rawquery": {
                            "description": "encoded query values, without '?'",
                            "type": "string"
                          },
                          "scheme": {
                            "type": "string"
                          },
                          "user": {
                            "description": "username and password information",
                            "type": "object"
                          }
                        },
                        "type": "object"
                      },
                      "scopes": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      },
                      "signature_algorithm": {
                        "description": "SignatureAlgorithm is the RSA algorithm used to sign JWT token. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\". Default value is RS256 and valid values RS256, RS384, RS512",
                        "type": "string"
                      },
                      "tlsconfig": {
                        "properties": {
                          "ca": {
                            "description": "Text of the CA cert to use for the targets.",
                            "type": "string"
                          },
                          "ca_file": {
                            "description": "The CA cert to use for the targets.",
                            "type": "string"
                          },
                          "ca_ref": {
                            "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                            "type": "string"
                          },
                          "cert": {
                            "description": "Text of the client cert file for the targets.",
                            "type": "string"
                          },
                          "cert_file": {
                            "description": "The client cert file for the targets.",
                            "type": "string"
                          },
                          "cert_ref": {
                            "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                            "type": "string"
                          },
                          "insecure_skip_verify": {
                            "description": "Disable target certificate validation.",
                            "type": "boolean"
                          },
                          "key": {
                            "description": "Text of the client key file for the targets.",
                            "type": "string"
                          },
                          "key_file": {
                            "description": "The client key file for the targets.",
                            "type": "string"
                          },
                          "key_ref": {
                            "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                            "type": "string"
                          },
                          "max_version": {
                            "description": "Maximum TLS version.",
                            "type": "integer"
                          },
                          "min_version": {
                            "description": "Minimum TLS version.",
                            "type": "integer"
                          },
                          "server_name": {
                            "description": "Used to verify the hostname for the targets.",
                            "type": "string"
                          }
                        },
                        "type": "object"
                      },
                      "token_url": {
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "proxy_connect_header": {
                    "additionalProperties": {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "description": "ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. Assume that at least _some_ of these headers are going to contain secrets and use Secret as the value type instead of string.",
                    "type": "object"
                  },
                  "proxy_from_environment": {
                    "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.",
                    "type": "boolean"
                  },
                  "proxy_url": {
                    "description": "HTTP proxy server to use to connect to the targets.",
                    "properties": {
                      "forcequery": {
                        "description": "append a query ('?') even if RawQuery is empty",
                        "type": "boolean"
                      },
                      "fragment": {
                        "description": "fragment for references, without '#'",
                        "type": "string"
                      },
                      "host": {
                        "description": "host or host:port (see Hostname and Port methods)",
                        "type": "string"
                      },
                      "omithost": {
                        "description": "do not emit empty host (authority)",
                        "type": "boolean"
                      },
                      "opaque": {
                        "description": "encoded opaque data",
                        "type": "string"
                      },
                      "path": {
                        "description": "path (relative paths may omit leading slash)",
                        "type": "string"
                      },
                      "rawfragment": {
                        "description": "encoded fragment hint (see EscapedFragment method)",
                        "type": "string"
                      },
                      "rawpath": {
                        "description": "encoded path hint (see EscapedPath method)",
                        "type": "string"
                      },
                      "rawquery": {
                        "description": "encoded query values, without '?'",
                        "type": "string"
                      },
                      "scheme": {
                        "type": "string"
                      },
                      "user": {
                        "description": "username and password information",
                        "type": "object"
                      }
                    },
                    "type": "object"
                  },
                  "tls_config": {
                    "description": "TLSConfig to use to connect to the targets.",
                    "properties": {
                      "ca": {
                        "description": "Text of the CA cert to use for the targets.",
                        "type": "string"
                      },
                      "ca_file": {
                        "description": "The CA cert to use for the targets.",
                        "type": "string"
                      },
                      "ca_ref": {
                        "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                        "type": "string"
                      },
                      "cert": {
                        "description": "Text of the client cert file for the targets.",
                        "type": "string"
                      },
                      "cert_file": {
                        "description": "The client cert file for the targets.",
                        "type": "string"
                      },
                      "cert_ref": {
                        "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                        "type": "string"
                      },
                      "insecure_skip_verify": {
                        "description": "Disable target certificate validation.",
                        "type": "boolean"
                      },
                      "key": {
                        "description": "Text of the client key file for the targets.",
                        "type": "string"
                      },
                      "key_file": {
                        "description": "The client key file for the targets.",
                        "type": "string"
                      },
                      "key_ref": {
                        "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                        "type": "string"
                      },
                      "max_version": {
                        "description": "Maximum TLS version.",
                        "type": "integer"
                      },
                      "min_version": {
                        "description": "Minimum TLS version.",
                        "type": "integer"
                      },
                      "server_name": {
                        "description": "Used to verify the hostname for the targets.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "name": {
                "type": "string"
              },
              "readrecent": {
                "type": "boolean"
              },
              "remotetimeout": {
                "type": "integer"
              },
              "requiredmatchers": {
                "additionalProperties": true,
                "description": "RequiredMatchers is an optional list of equality matchers which have to be present in a selector to query the remote read endpoint.",
                "type": "object"
              },
              "url": {
                "properties": {
                  "forcequery": {
                    "description": "append a query ('?') even if RawQuery is empty",
                    "type": "boolean"
                  },
                  "fragment": {
                    "description": "fragment for references, without '#'",
                    "type": "string"
                  },
                  "host": {
                    "description": "host or host:port (see Hostname and Port methods)",
                    "type": "string"
                  },
                  "omithost": {
                    "description": "do not emit empty host (authority)",
                    "type": "boolean"
                  },
                  "opaque": {
                    "description": "encoded opaque data",
                    "type": "string"
                  },
                  "path": {
                    "description": "path (relative paths may omit leading slash)",
                    "type": "string"
                  },
                  "rawfragment": {
                    "description": "encoded fragment hint (see EscapedFragment method)",
                    "type": "string"
                  },
                  "rawpath": {
                    "description": "encoded path hint (see EscapedPath method)",
                    "type": "string"
                  },
                  "rawquery": {
                    "description": "encoded query values, without '?'",
                    "type": "string"
                  },
                  "scheme": {
                    "type": "string"
                  },
                  "user": {
                    "description": "username and password information",
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          },
          "type": "array"
        },
        "remotewriteconfigs": {
          "items": {
            "properties": {
              "azureadconfig": {
                "properties": {
                  "cloud": {
                    "description": "Cloud is the Azure cloud in which the service is running. Example: AzurePublic/AzureGovernment/AzureChina.",
                    "type": "string"
                  },
                  "managedidentity": {
                    "description": "ManagedIdentity is the managed identity that is being used to authenticate.",
                    "properties": {
                      "clientid": {
                        "description": "ClientID is the clientId of the managed identity that is being used to authenticate.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "oauth": {
                    "description": "OAuth is the oauth config that is being used to authenticate.",
                    "properties": {
                      "clientid": {
                        "description": "ClientID is the clientId of the azure active directory application that is being used to authenticate.",
                        "type": "string"
                      },
                      "clientsecret": {
                        "description": "ClientSecret is the clientSecret of the azure active directory application that is being used to authenticate.",
                        "type": "string"
                      },
                      "tenantid": {
                        "description": "TenantID is the tenantId of the azure active directory application that is being used to authenticate.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "sdk": {
                    "description": "SDK is the SDK config that is being used to authenticate.",
                    "properties": {
                      "tenantid": {
                        "description": "TenantID is the tenantId of the azure active directory application that is being used to authenticate.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "workloadidentity": {
                    "description": "WorkloadIdentity is the workload identity that is being used to authenticate.",
                    "properties": {
                      "clientid": {
                        "description": "ClientID is the clientId of the Microsoft Entra application or user-assigned managed identity.",
                        "type": "string"
                      },
                      "tenantid": {
                        "description": "TenantID is the tenantId of the Microsoft Entra application or user-assigned managed identity. This should match the tenant ID where your application or managed identity is registered.",
                        "type": "string"
                      },
                      "tokenfilepath": {
                        "description": "TokenFilePath is the path to the token file provided by the Kubernetes service account projected volume. If not specified, it defaults to DefaultWorkloadIdentityTokenPath.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "googleiamconfig": {
                "properties": {
                  "credentialsfile": {
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "headers": {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              "httpclientconfig": {
                "description": "We cannot do proper Go type embedding below as the parser will then parse values arbitrarily into the overflow maps of further-down types.",
                "properties": {
                  "authorization": {
                    "description": "The HTTP authorization credentials for the targets.",
                    "properties": {
                      "credentials": {
                        "type": "string"
                      },
                      "credentials_file": {
                        "type": "string"
                      },
                      "credentials_ref": {
                        "description": "CredentialsRef is the name of the secret within the secret manager to use as credentials.",
                        "type": "string"
                      },
                      "type": {
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "basic_auth": {
                    "description": "The HTTP basic authentication credentials for the targets.",
                    "properties": {
                      "password": {
                        "type": "string"
                      },
                      "password_file": {
                        "type": "string"
                      },
                      "password_ref": {
                        "description": "PasswordRef is the name of the secret within the secret manager to use as the password.",
                        "type": "string"
                      },
                      "username": {
                        "type": "string"
                      },
                      "username_file": {
                        "type": "string"
                      },
                      "username_ref": {
                        "description": "UsernameRef is the name of the secret within the secret manager to use as the username.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "bearer_token": {
                    "deprecated": true,
                    "description": "The bearer token for the targets. Deprecated in favour of Authorization.Credentials.",
                    "type": "string"
                  },
                  "bearer_token_file": {
                    "deprecated": true,
                    "description": "The bearer token file for the targets. Deprecated in favour of Authorization.CredentialsFile.",
                    "type": "string"
                  },
                  "enable_http2": {
                    "description": "EnableHTTP2 specifies whether the client should configure HTTP2. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.",
                    "type": "boolean"
                  },
                  "follow_redirects": {
                    "description": "FollowRedirects specifies whether the client should follow HTTP 3xx redirects. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.",
                    "type": "boolean"
                  },
                  "http_headers": {
                    "description": "HTTPHeaders specify headers to inject in the requests. Those headers could be marshalled back to the users.",
                    "properties": {
                      "headers": {
                        "additionalProperties": {
                          "properties": {
                            "files": {
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "secrets": {
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "values": {
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            }
                          },
                          "type": "object"
                        },
                        "type": "object"
                      }
                    },
                    "type": "object"
                  },
                  "no_proxy": {
                    "description": "NoProxy contains addresses that should not use a proxy.",
                    "type": "string"
                  },
                  "oauth2": {
                    "description": "The OAuth2 client credentials used to fetch a token for the targets.",
                    "properties": {
                      "audience": {
                        "description": "Audience optionally specifies the intended audience of the request.  If empty, the value of TokenURL is used as the intended audience. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                        "type": "string"
                      },
                      "claims": {
                        "additionalProperties": {
                          "additionalProperties": true,
                          "type": "object"
                        },
                        "description": "Claims is a map of claims to be added to the JWT token. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                        "type": "object"
                      },
                      "client_certificate_key": {
                        "type": "string"
                      },
                      "client_certificate_key_file": {
                        "type": "string"
                      },
                      "client_certificate_key_id": {
                        "type": "string"
                      },
                      "client_certificate_key_ref": {
                        "description": "ClientCertificateKeyRef is the name of the secret within the secret manager to use as the client secret.",
                        "type": "string"
                      },
                      "client_id": {
                        "type": "string"
                      },
                      "client_secret": {
                        "type": "string"
                      },
                      "client_secret_file": {
                        "type": "string"
                      },
                      "client_secret_ref": {
                        "description": "ClientSecretRef is the name of the secret within the secret manager to use as the client secret.",
                        "type": "string"
                      },
                      "endpoint_params": {
                        "additionalProperties": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "grant_type": {
                        "description": "GrantType is the OAuth2 grant type to use. It can be one of \"client_credentials\" or \"urn:ietf:params:oauth:grant-type:jwt-bearer\" (RFC 7523). Default value is \"client_credentials\"",
                        "type": "string"
                      },
                      "iss": {
                        "description": "Iss is the OAuth client identifier used when communicating with the configured OAuth provider. Default value is client_id. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                        "type": "string"
                      },
                      "no_proxy": {
                        "description": "NoProxy contains addresses that should not use a proxy.",
                        "type": "string"
                      },
                      "proxy_connect_header": {
                        "additionalProperties": {
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "description": "ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. Assume that at least _some_ of these headers are going to contain secrets and use Secret as the value type instead of string.",
                        "type": "object"
                      },
                      "proxy_from_environment": {
                        "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.",
                        "type": "boolean"
                      },
                      "proxy_url": {
                        "description": "HTTP proxy server to use to connect to the targets.",
                        "properties": {
                          "forcequery": {
                            "description": "append a query ('?') even if RawQuery is empty",
                            "type": "boolean"
                          },
                          "fragment": {
                            "description": "fragment for references, without '#'",
                            "type": "string"
                          },
                          "host": {
                            "description": "host or host:port (see Hostname and Port methods)",
                            "type": "string"
                          },
                          "omithost": {
                            "description": "do not emit empty host (authority)",
                            "type": "boolean"
                          },
                          "opaque": {
                            "description": "encoded opaque data",
                            "type": "string"
                          },
                          "path": {
                            "description": "path (relative paths may omit leading slash)",
                            "type": "string"
                          },
                          "rawfragment": {
                            "description": "encoded fragment hint (see EscapedFragment method)",
                            "type": "string"
                          },
                          "rawpath": {
                            "description": "encoded path hint (see EscapedPath method)",
                            "type": "string"
                          },
                          "rawquery": {
                            "description": "encoded query values, without '?'",
                            "type": "string"
                          },
                          "scheme": {
                            "type": "string"
                          },
                          "user": {
                            "description": "username and password information",
                            "type": "object"
                          }
                        },
                        "type": "object"
                      },
                      "scopes": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      },
                      "signature_algorithm": {
                        "description": "SignatureAlgorithm is the RSA algorithm used to sign JWT token. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\". Default value is RS256 and valid values RS256, RS384, RS512",
                        "type": "string"
                      },
                      "tlsconfig": {
                        "properties": {
                          "ca": {
                            "description": "Text of the CA cert to use for the targets.",
                            "type": "string"
                          },
                          "ca_file": {
                            "description": "The CA cert to use for the targets.",
                            "type": "string"
                          },
                          "ca_ref": {
                            "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                            "type": "string"
                          },
                          "cert": {
                            "description": "Text of the client cert file for the targets.",
                            "type": "string"
                          },
                          "cert_file": {
                            "description": "The client cert file for the targets.",
                            "type": "string"
                          },
                          "cert_ref": {
                            "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                            "type": "string"
                          },
                          "insecure_skip_verify": {
                            "description": "Disable target certificate validation.",
                            "type": "boolean"
                          },
                          "key": {
                            "description": "Text of the client key file for the targets.",
                            "type": "string"
                          },
                          "key_file": {
                            "description": "The client key file for the targets.",
                            "type": "string"
                          },
                          "key_ref": {
                            "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                            "type": "string"
                          },
                          "max_version": {
                            "description": "Maximum TLS version.",
                            "type": "integer"
                          },
                          "min_version": {
                            "description": "Minimum TLS version.",
                            "type": "integer"
                          },
                          "server_name": {
                            "description": "Used to verify the hostname for the targets.",
                            "type": "string"
                          }
                        },
                        "type": "object"
                      },
                      "token_url": {
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "proxy_connect_header": {
                    "additionalProperties": {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "description": "ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. Assume that at least _some_ of these headers are going to contain secrets and use Secret as the value type instead of string.",
                    "type": "object"
                  },
                  "proxy_from_environment": {
                    "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.",
                    "type": "boolean"
                  },
                  "proxy_url": {
                    "description": "HTTP proxy server to use to connect to the targets.",
                    "properties": {
                      "forcequery": {
                        "description": "append a query ('?') even if RawQuery is empty",
                        "type": "boolean"
                      },
                      "fragment": {
                        "description": "fragment for references, without '#'",
                        "type": "string"
                      },
                      "host": {
                        "description": "host or host:port (see Hostname and Port methods)",
                        "type": "string"
                      },
                      "omithost": {
                        "description": "do not emit empty host (authority)",
                        "type": "boolean"
                      },
                      "opaque": {
                        "description": "encoded opaque data",
                        "type": "string"
                      },
                      "path": {
                        "description": "path (relative paths may omit leading slash)",
                        "type": "string"
                      },
                      "rawfragment": {
                        "description": "encoded fragment hint (see EscapedFragment method)",
                        "type": "string"
                      },
                      "rawpath": {
                        "description": "encoded path hint (see EscapedPath method)",
                        "type": "string"
                      },
                      "rawquery": {
                        "description": "encoded query values, without '?'",
                        "type": "string"
                      },
                      "scheme": {
                        "type": "string"
                      },
                      "user": {
                        "description": "username and password information",
                        "type": "object"
                      }
                    },
                    "type": "object"
                  },
                  "tls_config": {
                    "description": "TLSConfig to use to connect to the targets.",
                    "properties": {
                      "ca": {
                        "description": "Text of the CA cert to use for the targets.",
                        "type": "string"
                      },
                      "ca_file": {
                        "description": "The CA cert to use for the targets.",
                        "type": "string"
                      },
                      "ca_ref": {
                        "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                        "type": "string"
                      },
                      "cert": {
                        "description": "Text of the client cert file for the targets.",
                        "type": "string"
                      },
                      "cert_file": {
                        "description": "The client cert file for the targets.",
                        "type": "string"
                      },
                      "cert_ref": {
                        "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                        "type": "string"
                      },
                      "insecure_skip_verify": {
                        "description": "Disable target certificate validation.",
                        "type": "boolean"
                      },
                      "key": {
                        "description": "Text of the client key file for the targets.",
                        "type": "string"
                      },
                      "key_file": {
                        "description": "The client key file for the targets.",
                        "type": "string"
                      },
                      "key_ref": {
                        "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                        "type": "string"
                      },
                      "max_version": {
                        "description": "Maximum TLS version.",
                        "type": "integer"
                      },
                      "min_version": {
                        "description": "Minimum TLS version.",
                        "type": "integer"
                      },
                      "server_name": {
                        "description": "Used to verify the hostname for the targets.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "metadataconfig": {
                "properties": {
                  "maxsamplespersend": {
                    "description": "Maximum number of samples per send.",
                    "type": "integer"
                  },
                  "send": {
                    "description": "Send controls whether we send metric metadata to remote storage.",
                    "type": "boolean"
                  },
                  "sendinterval": {
                    "description": "SendInterval controls how frequently we send metric metadata.",
                    "type": "integer"
                  }
                },
                "type": "object"
              },
              "name": {
                "type": "string"
              },
              "protobufmessage": {
                "description": "ProtobufMessage specifies the protobuf message to use against the remote receiver as specified in https://prometheus.io/docs/specs/remote_write_spec_2_0/",
                "type": "string"
              },
              "queueconfig": {
                "properties": {
                  "batchsenddeadline": {
                    "description": "Maximum time sample will wait in buffer.",
                    "type": "integer"
                  },
                  "capacity": {
                    "description": "Number of samples to buffer per shard before we block. Defaults to MaxSamplesPerSend.",
                    "type": "integer"
                  },
                  "maxbackoff": {
                    "type": "integer"
                  },
                  "maxsamplespersend": {
                    "description": "Maximum number of samples per send.",
                    "type": "integer"
                  },
                  "maxshards": {
                    "description": "Max number of shards, i.e. amount of concurrency.",
                    "type": "integer"
                  },
                  "minbackoff": {
                    "description": "On recoverable errors, backoff exponentially.",
                    "type": "integer"
                  },
                  "minshards": {
                    "description": "Min number of shards, i.e. amount of concurrency.",
                    "type": "integer"
                  },
                  "retryonratelimit": {
                    "type": "boolean"
                  },
                  "sampleagelimit": {
                    "description": "Samples older than the limit will be dropped.",
                    "type": "integer"
                  }
                },
                "type": "object"
              },
              "remotetimeout": {
                "type": "integer"
              },
              "roundrobindns": {
                "type": "boolean"
              },
              "sendexemplars": {
                "type": "boolean"
              },
              "sendnativehistograms": {
                "type": "boolean"
              },
              "sigv4config": {
                "properties": {
                  "accesskey": {
                    "type": "string"
                  },
                  "profile": {
                    "type": "string"
                  },
                  "region": {
                    "type": "string"
                  },
                  "rolearn": {
                    "type": "string"
                  },
                  "secretkey": {
                    "type": "string"
                  },
                  "servicename": {
                    "type": "string"
                  },
                  "usefipsstsendpoint": {
                    "type": "boolean"
                  }
                },
                "type": "object"
              },
              "url": {
                "properties": {
                  "forcequery": {
                    "description": "append a query ('?') even if RawQuery is empty",
                    "type": "boolean"
                  },
                  "fragment": {
                    "description": "fragment for references, without '#'",
                    "type": "string"
                  },
                  "host": {
                    "description": "host or host:port (see Hostname and Port methods)",
                    "type": "string"
                  },
                  "omithost": {
                    "description": "do not emit empty host (authority)",
                    "type": "boolean"
                  },
                  "opaque": {
                    "description": "encoded opaque data",
                    "type": "string"
                  },
                  "path": {
                    "description": "path (relative paths may omit leading slash)",
                    "type": "string"
                  },
                  "rawfragment": {
                    "description": "encoded fragment hint (see EscapedFragment method)",
                    "type": "string"
                  },
                  "rawpath": {
                    "description": "encoded path hint (see EscapedPath method)",
                    "type": "string"
                  },
                  "rawquery": {
                    "description": "encoded query values, without '?'",
                    "type": "string"
                  },
                  "scheme": {
                    "type": "string"
                  },
                  "user": {
                    "description": "username and password information",
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "writerelabelconfigs": {
                "items": {
                  "properties": {
                    "action": {
                      "description": "Action is the action to be performed for the relabeling.",
                      "type": "string"
                    },
                    "modulus": {
                      "description": "Modulus to take of the hash of concatenated values from the source labels.",
                      "type": "integer"
                    },
                    "namevalidationscheme": {
                      "description": "NameValidationScheme to use when validating labels.",
                      "type": "integer"
                    },
                    "regex": {
                      "description": "Regex against which the concatenation is matched.",
                      "type": "object"
                    },
                    "replacement": {
                      "description": "Replacement is the regex replacement pattern to be used.",
                      "type": "string"
                    },
                    "separator": {
                      "description": "Separator is the string between concatenated values from the source labels.",
                      "type": "string"
                    },
                    "sourceLabels": {
                      "description": "A list of labels from which values are taken and concatenated with the configured separator in order.",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "targetLabel": {
                      "description": "TargetLabel is the label to which the resulting string is written in a replacement. Regexp interpolation is allowed for the replace action.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              }
            },
            "type": "object"
          },
          "type": "array"
        },
        "rulefiles": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "runtime": {
          "properties": {
            "gogc": {
              "description": "The Go garbage collection target percentage.",
              "type": "integer"
            }
          },
          "type": "object"
        },
        "scrapeconfigfiles": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "scrapeconfigs": {
          "items": {
            "properties": {
              "alwaysscrapeclassichistograms": {
                "description": "Whether to scrape a classic histogram, even if it is also exposed as a native histogram.",
                "type": "boolean"
              },
              "bodysizelimit": {
                "description": "An uncompressed response body larger than this many bytes will cause the scrape to fail. 0 means no limit.",
                "type": "integer"
              },
              "convertclassichistogramstonhcb": {
                "description": "Whether to convert all scraped classic histograms into a native histogram with custom buckets.",
                "type": "boolean"
              },
              "enablecompression": {
                "description": "Indicator whether to request compressed response from the target.",
                "type": "boolean"
              },
              "honorlabels": {
                "description": "Indicator whether the scraped metrics should remain unmodified.",
                "type": "boolean"
              },
              "honortimestamps": {
                "description": "Indicator whether the scraped timestamps should be respected.",
                "type": "boolean"
              },
              "httpclientconfig": {
                "properties": {
                  "authorization": {
                    "description": "The HTTP authorization credentials for the targets.",
                    "properties": {
                      "credentials": {
                        "type": "string"
                      },
                      "credentials_file": {
                        "type": "string"
                      },
                      "credentials_ref": {
                        "description": "CredentialsRef is the name of the secret within the secret manager to use as credentials.",
                        "type": "string"
                      },
                      "type": {
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "basic_auth": {
                    "description": "The HTTP basic authentication credentials for the targets.",
                    "properties": {
                      "password": {
                        "type": "string"
                      },
                      "password_file": {
                        "type": "string"
                      },
                      "password_ref": {
                        "description": "PasswordRef is the name of the secret within the secret manager to use as the password.",
                        "type": "string"
                      },
                      "username": {
                        "type": "string"
                      },
                      "username_file": {
                        "type": "string"
                      },
                      "username_ref": {
                        "description": "UsernameRef is the name of the secret within the secret manager to use as the username.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "bearer_token": {
                    "deprecated": true,
                    "description": "The bearer token for the targets. Deprecated in favour of Authorization.Credentials.",
                    "type": "string"
                  },
                  "bearer_token_file": {
                    "deprecated": true,
                    "description": "The bearer token file for the targets. Deprecated in favour of Authorization.CredentialsFile.",
                    "type": "string"
                  },
                  "enable_http2": {
                    "description": "EnableHTTP2 specifies whether the client should configure HTTP2. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.",
                    "type": "boolean"
                  },
                  "follow_redirects": {
                    "description": "FollowRedirects specifies whether the client should follow HTTP 3xx redirects. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.",
                    "type": "boolean"
                  },
                  "http_headers": {
                    "description": "HTTPHeaders specify headers to inject in the requests. Those headers could be marshalled back to the users.",
                    "properties": {
                      "headers": {
                        "additionalProperties": {
                          "properties": {
                            "files": {
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "secrets": {
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "values": {
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            }
                          },
                          "type": "object"
                        },
                        "type": "object"
                      }
                    },
                    "type": "object"
                  },
                  "no_proxy": {
                    "description": "NoProxy contains addresses that should not use a proxy.",
                    "type": "string"
                  },
                  "oauth2": {
                    "description": "The OAuth2 client credentials used to fetch a token for the targets.",
                    "properties": {
                      "audience": {
                        "description": "Audience optionally specifies the intended audience of the request.  If empty, the value of TokenURL is used as the intended audience. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                        "type": "string"
                      },
                      "claims": {
                        "additionalProperties": {
                          "additionalProperties": true,
                          "type": "object"
                        },
                        "description": "Claims is a map of claims to be added to the JWT token. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                        "type": "object"
                      },
                      "client_certificate_key": {
                        "type": "string"
                      },
                      "client_certificate_key_file": {
                        "type": "string"
                      },
                      "client_certificate_key_id": {
                        "type": "string"
                      },
                      "client_certificate_key_ref": {
                        "description": "ClientCertificateKeyRef is the name of the secret within the secret manager to use as the client secret.",
                        "type": "string"
                      },
                      "client_id": {
                        "type": "string"
                      },
                      "client_secret": {
                        "type": "string"
                      },
                      "client_secret_file": {
                        "type": "string"
                      },
                      "client_secret_ref": {
                        "description": "ClientSecretRef is the name of the secret within the secret manager to use as the client secret.",
                        "type": "string"
                      },
                      "endpoint_params": {
                        "additionalProperties": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "grant_type": {
                        "description": "GrantType is the OAuth2 grant type to use. It can be one of \"client_credentials\" or \"urn:ietf:params:oauth:grant-type:jwt-bearer\" (RFC 7523). Default value is \"client_credentials\"",
                        "type": "string"
                      },
                      "iss": {
                        "description": "Iss is the OAuth client identifier used when communicating with the configured OAuth provider. Default value is client_id. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                        "type": "string"
                      },
                      "no_proxy": {
                        "description": "NoProxy contains addresses that should not use a proxy.",
                        "type": "string"
                      },
                      "proxy_connect_header": {
                        "additionalProperties": {
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "description": "ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. Assume that at least _some_ of these headers are going to contain secrets and use Secret as the value type instead of string.",
                        "type": "object"
                      },
                      "proxy_from_environment": {
                        "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.",
                        "type": "boolean"
                      },
                      "proxy_url": {
                        "description": "HTTP proxy server to use to connect to the targets.",
                        "properties": {
                          "forcequery": {
                            "description": "append a query ('?') even if RawQuery is empty",
                            "type": "boolean"
                          },
                          "fragment": {
                            "description": "fragment for references, without '#'",
                            "type": "string"
                          },
                          "host": {
                            "description": "host or host:port (see Hostname and Port methods)",
                            "type": "string"
                          },
                          "omithost": {
                            "description": "do not emit empty host (authority)",
                            "type": "boolean"
                          },
                          "opaque": {
                            "description": "encoded opaque data",
                            "type": "string"
                          },
                          "path": {
                            "description": "path (relative paths may omit leading slash)",
                            "type": "string"
                          },
                          "rawfragment": {
                            "description": "encoded fragment hint (see EscapedFragment method)",
                            "type": "string"
                          },
                          "rawpath": {
                            "description": "encoded path hint (see EscapedPath method)",
                            "type": "string"
                          },
                          "rawquery": {
                            "description": "encoded query values, without '?'",
                            "type": "string"
                          },
                          "scheme": {
                            "type": "string"
                          },
                          "user": {
                            "description": "username and password information",
                            "type": "object"
                          }
                        },
                        "type": "object"
                      },
                      "scopes": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      },
                      "signature_algorithm": {
                        "description": "SignatureAlgorithm is the RSA algorithm used to sign JWT token. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\". Default value is RS256 and valid values RS256, RS384, RS512",
                        "type": "string"
                      },
                      "tlsconfig": {
                        "properties": {
                          "ca": {
                            "description": "Text of the CA cert to use for the targets.",
                            "type": "string"
                          },
                          "ca_file": {
                            "description": "The CA cert to use for the targets.",
                            "type": "string"
                          },
                          "ca_ref": {
                            "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                            "type": "string"
                          },
                          "cert": {
                            "description": "Text of the client cert file for the targets.",
                            "type": "string"
                          },
                          "cert_file": {
                            "description": "The client cert file for the targets.",
                            "type": "string"
                          },
                          "cert_ref": {
                            "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                            "type": "string"
                          },
                          "insecure_skip_verify": {
                            "description": "Disable target certificate validation.",
                            "type": "boolean"
                          },
                          "key": {
                            "description": "Text of the client key file for the targets.",
                            "type": "string"
                          },
                          "key_file": {
                            "description": "The client key file for the targets.",
                            "type": "string"
                          },
                          "key_ref": {
                            "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                            "type": "string"
                          },
                          "max_version": {
                            "description": "Maximum TLS version.",
                            "type": "integer"
                          },
                          "min_version": {
                            "description": "Minimum TLS version.",
                            "type": "integer"
                          },
                          "server_name": {
                            "description": "Used to verify the hostname for the targets.",
                            "type": "string"
                          }
                        },
                        "type": "object"
                      },
                      "token_url": {
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "proxy_connect_header": {
                    "additionalProperties": {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "description": "ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. Assume that at least _some_ of these headers are going to contain secrets and use Secret as the value type instead of string.",
                    "type": "object"
                  },
                  "proxy_from_environment": {
                    "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.",
                    "type": "boolean"
                  },
                  "proxy_url": {
                    "description": "HTTP proxy server to use to connect to the targets.",
                    "properties": {
                      "forcequery": {
                        "description": "append a query ('?') even if RawQuery is empty",
                        "type": "boolean"
                      },
                      "fragment": {
                        "description": "fragment for references, without '#'",
                        "type": "string"
                      },
                      "host": {
                        "description": "host or host:port (see Hostname and Port methods)",
                        "type": "string"
                      },
                      "omithost": {
                        "description": "do not emit empty host (authority)",
                        "type": "boolean"
                      },
                      "opaque": {
                        "description": "encoded opaque data",
                        "type": "string"
                      },
                      "path": {
                        "description": "path (relative paths may omit leading slash)",
                        "type": "string"
                      },
                      "rawfragment": {
                        "description": "encoded fragment hint (see EscapedFragment method)",
                        "type": "string"
                      },
                      "rawpath": {
                        "description": "encoded path hint (see EscapedPath method)",
                        "type": "string"
                      },
                      "rawquery": {
                        "description": "encoded query values, without '?'",
                        "type": "string"
                      },
                      "scheme": {
                        "type": "string"
                      },
                      "user": {
                        "description": "username and password information",
                        "type": "object"
                      }
                    },
                    "type": "object"
                  },
                  "tls_config": {
                    "description": "TLSConfig to use to connect to the targets.",
                    "properties": {
                      "ca": {
                        "description": "Text of the CA cert to use for the targets.",
                        "type": "string"
                      },
                      "ca_file": {
                        "description": "The CA cert to use for the targets.",
                        "type": "string"
                      },
                      "ca_ref": {
                        "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                        "type": "string"
                      },
                      "cert": {
                        "description": "Text of the client cert file for the targets.",
                        "type": "string"
                      },
                      "cert_file": {
                        "description": "The client cert file for the targets.",
                        "type": "string"
                      },
                      "cert_ref": {
                        "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                        "type": "string"
                      },
                      "insecure_skip_verify": {
                        "description": "Disable target certificate validation.",
                        "type": "boolean"
                      },
                      "key": {
                        "description": "Text of the client key file for the targets.",
                        "type": "string"
                      },
                      "key_file": {
                        "description": "The client key file for the targets.",
                        "type": "string"
                      },
                      "key_ref": {
                        "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                        "type": "string"
                      },
                      "max_version": {
                        "description": "Maximum TLS version.",
                        "type": "integer"
                      },
                      "min_version": {
                        "description": "Minimum TLS version.",
                        "type": "integer"
                      },
                      "server_name": {
                        "description": "Used to verify the hostname for the targets.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "jobname": {
                "description": "The job name to which the job label is set by default.",
                "type": "string"
              },
              "keepdroppedtargets": {
                "description": "Keep no more than this many dropped targets per job. 0 means no limit.",
                "type": "integer"
              },
              "labellimit": {
                "description": "More than this many labels post metric-relabeling will cause the scrape to fail. 0 means no limit.",
                "type": "integer"
              },
              "labelnamelengthlimit": {
                "description": "More than this label name length post metric-relabeling will cause the scrape to fail. 0 means no limit.",
                "type": "integer"
              },
              "labelvaluelengthlimit": {
                "description": "More than this label value length post metric-relabeling will cause the scrape to fail. 0 means no limit.",
                "type": "integer"
              },
              "metricnameescapingscheme": {
                "description": "Metric name escaping mode to request through content negotiation. Can be blank in config files but must have a value if a ScrapeConfig is created programmatically.",
                "type": "string"
              },
              "metricnamevalidationscheme": {
                "description": "Allow UTF8 Metric and Label Names. Can be blank in config files but must have a value if a ScrapeConfig is created programmatically.",
                "type": "integer"
              },
              "metricrelabelconfigs": {
                "description": "List of metric relabel configurations.",
                "items": {
                  "properties": {
                    "action": {
                      "description": "Action is the action to be performed for the relabeling.",
                      "type": "string"
                    },
                    "modulus": {
                      "description": "Modulus to take of the hash of concatenated values from the source labels.",
                      "type": "integer"
                    },
                    "namevalidationscheme": {
                      "description": "NameValidationScheme to use when validating labels.",
                      "type": "integer"
                    },
                    "regex": {
                      "description": "Regex against which the concatenation is matched.",
                      "type": "object"
                    },
                    "replacement": {
                      "description": "Replacement is the regex replacement pattern to be used.",
                      "type": "string"
                    },
                    "separator": {
                      "description": "Separator is the string between concatenated values from the source labels.",
                      "type": "string"
                    },
                    "sourceLabels": {
                      "description": "A list of labels from which values are taken and concatenated with the configured separator in order.",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "targetLabel": {
                      "description": "TargetLabel is the label to which the resulting string is written in a replacement. Regexp interpolation is allowed for the replace action.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "metricspath": {
                "description": "The HTTP resource path on which to fetch metrics from targets.",
                "type": "string"
              },
              "nativehistogrambucketlimit": {
                "description": "If there are more than this many buckets in a native histogram, buckets will be merged to stay within the limit.",
                "type": "integer"
              },
              "nativehistogramminbucketfactor": {
                "description": "If the growth factor of one bucket to the next is smaller than this, buckets will be merged to increase the factor sufficiently.",
                "type": "number"
              },
              "params": {
                "additionalProperties": {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "description": "A set of query parameters with which the target is scraped.",
                "type": "object"
              },
              "relabelconfigs": {
                "description": "List of target relabel configurations.",
                "items": {
                  "properties": {
                    "action": {
                      "description": "Action is the action to be performed for the relabeling.",
                      "type": "string"
                    },
                    "modulus": {
                      "description": "Modulus to take of the hash of concatenated values from the source labels.",
                      "type": "integer"
                    },
                    "namevalidationscheme": {
                      "description": "NameValidationScheme to use when validating labels.",
                      "type": "integer"
                    },
                    "regex": {
                      "description": "Regex against which the concatenation is matched.",
                      "type": "object"
                    },
                    "replacement": {
                      "description": "Replacement is the regex replacement pattern to be used.",
                      "type": "string"
                    },
                    "separator": {
                      "description": "Separator is the string between concatenated values from the source labels.",
                      "type": "string"
                    },
                    "sourceLabels": {
                      "description": "A list of labels from which values are taken and concatenated with the configured separator in order.",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "targetLabel": {
                      "description": "TargetLabel is the label to which the resulting string is written in a replacement. Regexp interpolation is allowed for the replace action.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "samplelimit": {
                "description": "More than this many samples post metric-relabeling will cause the scrape to fail. 0 means no limit.",
                "type": "integer"
              },
              "scheme": {
                "description": "The URL scheme with which to fetch metrics from targets.",
                "type": "string"
              },
              "scrapefailurelogfile": {
                "description": "File to which scrape failures are logged.",
                "type": "string"
              },
              "scrapefallbackprotocol": {
                "description": "The fallback protocol to use if the Content-Type provided by the target is not provided, blank, or not one of the expected values. Supported values (case sensitive): PrometheusProto, OpenMetricsText0.0.1, OpenMetricsText1.0.0, PrometheusText1.0.0, PrometheusText0.0.4.",
                "type": "string"
              },
              "scrapeinterval": {
                "description": "How frequently to scrape the targets of this scrape config.",
                "type": "integer"
              },
              "scrapeprotocols": {
                "description": "The protocols to negotiate during a scrape. It tells clients what protocol are accepted by Prometheus and with what preference (most wanted is first). Supported values (case sensitive): PrometheusProto, OpenMetricsText0.0.1, OpenMetricsText1.0.0, PrometheusText1.0.0, PrometheusText0.0.4.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "scrapetimeout": {
                "description": "The timeout for scraping targets of this config.",
                "type": "integer"
              },
              "servicediscoveryconfigs": {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              },
              "targetlimit": {
                "description": "More than this many targets after the target relabeling will cause the scrapes to fail. 0 means no limit.",
                "type": "integer"
              },
              "tracktimestampsstaleness": {
                "description": "Indicator whether to track the staleness of the scraped timestamps.",
                "type": "boolean"
              }
            },
            "type": "object"
          },
          "type": "array"
        },
        "storageconfig": {
          "properties": {
            "exemplarsconfig": {
              "properties": {
                "maxexemplars": {
                  "description": "MaxExemplars sets the size, in # of exemplars stored, of the single circular buffer used to store exemplars in memory. Use a value of 0 or less than 0 to disable the storage without having to restart Prometheus.",
                  "type": "integer"
                }
              },
              "type": "object"
            },
            "tsdbconfig": {
              "properties": {
                "outofordertimewindow": {
                  "description": "OutOfOrderTimeWindow sets how long back in time an out-of-order sample can be inserted into the TSDB. This flag is typically set while unmarshaling the configuration file and translating OutOfOrderTimeWindowFlag's duration. The unit of this flag is expected to be the same as any other timestamp in the TSDB.",
                  "type": "integer"
                },
                "outofordertimewindowflag": {
                  "description": "OutOfOrderTimeWindowFlag holds the parsed duration from the config file. During unmarshall, this is converted into milliseconds and stored in OutOfOrderTimeWindow. This should not be used directly and must be converted into OutOfOrderTimeWindow.",
                  "type": "integer"
                }
              },
              "type": "object"
            }
          },
          "type": "object"
        },
        "tracingconfig": {
          "properties": {
            "clienttype": {
              "type": "string"
            },
            "compression": {
              "type": "string"
            },
            "endpoint": {
              "type": "string"
            },
            "headers": {
              "additionalProperties": {
                "type": "string"
              },
              "type": "object"
            },
            "insecure": {
              "type": "boolean"
            },
            "samplingfraction": {
              "type": "number"
            },
            "timeout": {
              "type": "integer"
            },
            "tlsconfig": {
              "properties": {
                "ca": {
                  "description": "Text of the CA cert to use for the targets.",
                  "type": "string"
                },
                "ca_file": {
                  "description": "The CA cert to use for the targets.",
                  "type": "string"
                },
                "ca_ref": {
                  "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                  "type": "string"
                },
                "cert": {
                  "description": "Text of the client cert file for the targets.",
                  "type": "string"
                },
                "cert_file": {
                  "description": "The client cert file for the targets.",
                  "type": "string"
                },
                "cert_ref": {
                  "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                  "type": "string"
                },
                "insecure_skip_verify": {
                  "description": "Disable target certificate validation.",
                  "type": "boolean"
                },
                "key": {
                  "description": "Text of the client key file for the targets.",
                  "type": "string"
                },
                "key_file": {
                  "description": "The client key file for the targets.",
                  "type": "string"
                },
                "key_ref": {
                  "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                  "type": "string"
                },
                "max_version": {
                  "description": "Maximum TLS version.",
                  "type": "integer"
                },
                "min_version": {
                  "description": "Minimum TLS version.",
                  "type": "integer"
                },
                "server_name": {
                  "description": "Used to verify the hostname for the targets.",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "type": "object"
        }
      },
      "type": "object"
    },
    "report_extra_scrape_metrics": {
      "deprecated": true,
      "description": "ReportExtraScrapeMetrics - enables reporting of additional metrics for Prometheus client like scrape_body_size_bytes Deprecated: use the feature gate \"receiver.prometheusreceiver.EnableReportExtraScrapeMetrics\" instead.",
      "type": "boolean"
    },
    "start_time_metric_regex": {
      "type": "string"
    },
    "target_allocator": {
      "properties": {
        "auth": {
          "description": "Auth configuration for outgoing HTTP calls.",
          "properties": {
            "authenticator": {
              "description": "AuthenticatorID specifies the name of the extension to use in order to authenticate the incoming data point.",
              "type": "object"
            }
          },
          "type": "object"
        },
        "collector_id": {
          "type": "string"
        },
        "compression": {
          "description": "The compression key for supported compression types within collector.",
          "type": "string"
        },
        "compression_params": {
          "description": "Advanced configuration options for the Compression",
          "properties": {
            "level": {
              "type": "integer"
            }
          },
          "type": "object"
        },
        "cookies": {
          "description": "Cookies configures the cookie management of the HTTP client.",
          "type": "object"
        },
        "disable_keep_alives": {
          "description": "DisableKeepAlives, if true, disables HTTP keep-alives and will only use the connection to the server for a single HTTP request. WARNING: enabling this option can result in significant overhead establishing a new HTTP(S) connection for every request. Before enabling this option please consider whether changes to idle connection settings can achieve your goal.",
          "type": "boolean"
        },
        "endpoint": {
          "description": "The target URL to send data to (e.g.: http://some.url:9411/v1/traces).",
          "type": "string"
        },
        "force_attempt_http2": {
          "description": "Enabling ForceAttemptHTTP2 forces the HTTP transport to use the HTTP/2 protocol. By default, this is set to true. NOTE: HTTP/2 does not support settings such as MaxConnsPerHost, MaxIdleConnsPerHost and MaxIdleConns.",
          "type": "boolean"
        },
        "headers": {
          "description": "Additional headers attached to each HTTP request sent by the client. Existing header values are overwritten if collision happens. Header values are opaque since they may be sensitive.",
          "items": {
            "properties": {
              "name": {
                "type": "string"
              },
              "value": {
                "type": "string"
              }
            },
            "type": "object"
          },
          "type": "array"
        },
        "http2_ping_timeout": {
          "description": "HTTP2PingTimeout if there's no response to the ping within the configured value, the connection will be closed. If not set or set to 0, it defaults to 15s.",
          "pattern": "^[0-9]+(ns|us|µs|ms|s|m|h)$",
          "type": "string"
        },
        "http2_read_idle_timeout": {
          "description": "This is needed in case you run into https://github.com/golang/go/issues/59690 https://github.com/golang/go/issues/36026 HTTP2ReadIdleTimeout if the connection has been idle for the configured value send a ping frame for health check 0s means no health check will be performed.",
          "pattern": "^[0-9]+(ns|us|µs|ms|s|m|h)$",
          "type": "string"
        },
        "http_scrape_config": {
          "properties": {
            "authorization": {
              "properties": {
                "credentials": {
                  "type": "string"
                },
                "credentials_file": {
                  "type": "string"
                },
                "credentials_ref": {
                  "description": "CredentialsRef is the name of the secret within the secret manager to use as credentials.",
                  "type": "string"
                },
                "type": {
                  "type": "string"
                }
              },
              "type": "object"
            },
            "basic_auth": {
              "properties": {
                "password": {
                  "type": "string"
                },
                "password_file": {
                  "type": "string"
                },
                "password_ref": {
                  "description": "PasswordRef is the name of the secret within the secret manager to use as the password.",
                  "type": "string"
                },
                "username": {
                  "type": "string"
                },
                "username_file": {
                  "type": "string"
                },
                "username_ref": {
                  "description": "UsernameRef is the name of the secret within the secret manager to use as the username.",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "bearer_token": {
              "type": "string"
            },
            "bearer_token_file": {
              "type": "string"
            },
            "enable_http2": {
              "type": "boolean"
            },
            "follow_redirects": {
              "type": "boolean"
            },
            "http_headers": {
              "properties": {
                "headers": {
                  "additionalProperties": {
                    "properties": {
                      "files": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      },
                      "secrets": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      },
                      "values": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    },
                    "type": "object"
                  },
                  "type": "object"
                }
              },
              "type": "object"
            },
            "no_proxy": {
              "description": "NoProxy contains addresses that should not use a proxy.",
              "type": "string"
            },
            "oauth2": {
              "properties": {
                "audience": {
                  "description": "Audience optionally specifies the intended audience of the request.  If empty, the value of TokenURL is used as the intended audience. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                  "type": "string"
                },
                "claims": {
                  "additionalProperties": {
                    "additionalProperties": true,
                    "type": "object"
                  },
                  "description": "Claims is a map of claims to be added to the JWT token. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                  "type": "object"
                },
                "client_certificate_key": {
                  "type": "string"
                },
                "client_certificate_key_file": {
                  "type": "string"
                },
                "client_certificate_key_id": {
                  "type": "string"
                },
                "client_certificate_key_ref": {
                  "description": "ClientCertificateKeyRef is the name of the secret within the secret manager to use as the client secret.",
                  "type": "string"
                },
                "client_id": {
                  "type": "string"
                },
                "client_secret": {
                  "type": "string"
                },
                "client_secret_file": {
                  "type": "string"
                },
                "client_secret_ref": {
                  "description": "ClientSecretRef is the name of the secret within the secret manager to use as the client secret.",
                  "type": "string"
                },
                "endpoint_params": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                "grant_type": {
                  "description": "GrantType is the OAuth2 grant type to use. It can be one of \"client_credentials\" or \"urn:ietf:params:oauth:grant-type:jwt-bearer\" (RFC 7523). Default value is \"client_credentials\"",
                  "type": "string"
                },
                "iss": {
                  "description": "Iss is the OAuth client identifier used when communicating with the configured OAuth provider. Default value is client_id. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                  "type": "string"
                },
                "no_proxy": {
                  "description": "NoProxy contains addresses that should not use a proxy.",
                  "type": "string"
                },
                "proxy_connect_header": {
                  "additionalProperties": {
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "description": "ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. Assume that at least _some_ of these headers are going to contain secrets and use Secret as the value type instead of string.",
                  "type": "object"
                },
                "proxy_from_environment": {
                  "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.",
                  "type": "boolean"
                },
                "proxy_url": {
                  "description": "HTTP proxy server to use to connect to the targets.",
                  "properties": {
                    "forcequery": {
                      "description": "append a query ('?') even if RawQuery is empty",
                      "type": "boolean"
                    },
                    "fragment": {
                      "description": "fragment for references, without '#'",
                      "type": "string"
                    },
                    "host": {
                      "description": "host or host:port (see Hostname and Port methods)",
                      "type": "string"
                    },
                    "omithost": {
                      "description": "do not emit empty host (authority)",
                      "type": "boolean"
                    },
                    "opaque": {
                      "description": "encoded opaque data",
                      "type": "string"
                    },
                    "path": {
                      "description": "path (relative paths may omit leading slash)",
                      "type": "string"
                    },
                    "rawfragment": {
                      "description": "encoded fragment hint (see EscapedFragment method)",
                      "type": "string"
                    },
                    "rawpath": {
                      "description": "encoded path hint (see EscapedPath method)",
                      "type": "string"
                    },
                    "rawquery": {
                      "description": "encoded query values, without '?'",
                      "type": "string"
                    },
                    "scheme": {
                      "type": "string"
                    },
                    "user": {
                      "description": "username and password information",
                      "type": "object"
                    }
                  },
                  "type": "object"
                },
                "scopes": {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "signature_algorithm": {
                  "description": "SignatureAlgorithm is the RSA algorithm used to sign JWT token. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\". Default value is RS256 and valid values RS256, RS384, RS512",
                  "type": "string"
                },
                "tlsconfig": {
                  "properties": {
                    "ca": {
                      "description": "Text of the CA cert to use for the targets.",
                      "type": "string"
                    },
                    "ca_file": {
                      "description": "The CA cert to use for the targets.",
                      "type": "string"
                    },
                    "ca_ref": {
                      "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                      "type": "string"
                    },
                    "cert": {
                      "description": "Text of the client cert file for the targets.",
                      "type": "string"
                    },
                    "cert_file": {
                      "description": "The client cert file for the targets.",
                      "type": "string"
                    },
                    "cert_ref": {
                      "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                      "type": "string"
                    },
                    "insecure_skip_verify": {
                      "description": "Disable target certificate validation.",
                      "type": "boolean"
                    },
                    "key": {
                      "description": "Text of the client key file for the targets.",
                      "type": "string"
                    },
                    "key_file": {
                      "description": "The client key file for the targets.",
                      "type": "string"
                    },
                    "key_ref": {
                      "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                      "type": "string"
                    },
                    "max_version": {
                      "description": "Maximum TLS version.",
                      "type": "integer"
                    },
                    "min_version": {
                      "description": "Minimum TLS version.",
                      "type": "integer"
                    },
                    "server_name": {
                      "description": "Used to verify the hostname for the targets.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "token_url": {
                  "type": "string"
                }
              },
              "type": "object"
            },
            "proxy_connect_header": {
              "additionalProperties": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "description": "ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. Assume that at least _some_ of these headers are going to contain secrets and use Secret as the value type instead of string.",
              "type": "object"
            },
            "proxy_from_environment": {
              "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.",
              "type": "boolean"
            },
            "proxy_url": {
              "description": "HTTP proxy server to use to connect to the targets.",
              "properties": {
                "forcequery": {
                  "description": "append a query ('?') even if RawQuery is empty",
                  "type": "boolean"
                },
                "fragment": {
                  "description": "fragment for references, without '#'",
                  "type": "string"
                },
                "host": {
                  "description": "host or host:port (see Hostname and Port methods)",
                  "type": "string"
                },
                "omithost": {
                  "description": "do not emit empty host (authority)",
                  "type": "boolean"
                },
                "opaque": {
                  "description": "encoded opaque data",
                  "type": "string"
                },
                "path": {
                  "description": "path (relative paths may omit leading slash)",
                  "type": "string"
                },
                "rawfragment": {
                  "description": "encoded fragment hint (see EscapedFragment method)",
                  "type": "string"
                },
                "rawpath": {
                  "description": "encoded path hint (see EscapedPath method)",
                  "type": "string"
                },
                "rawquery": {
                  "description": "encoded query values, without '?'",
                  "type": "string"
                },
                "scheme": {
                  "type": "string"
                },
                "user": {
                  "description": "username and password information",
                  "type": "object"
                }
              },
              "type": "object"
            },
            "tls_config": {
              "properties": {
                "ca": {
                  "description": "Text of the CA cert to use for the targets.",
                  "type": "string"
                },
                "ca_file": {
                  "description": "The CA cert to use for the targets.",
                  "type": "string"
                },
                "ca_ref": {
                  "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                  "type": "string"
                },
                "cert": {
                  "description": "Text of the client cert file for the targets.",
                  "type": "string"
                },
                "cert_file": {
                  "description": "The client cert file for the targets.",
                  "type": "string"
                },
                "cert_ref": {
                  "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                  "type": "string"
                },
                "insecure_skip_verify": {
                  "description": "Disable target certificate validation.",
                  "type": "boolean"
                },
                "key": {
                  "description": "Text of the client key file for the targets.",
                  "type": "string"
                },
                "key_file": {
                  "description": "The client key file for the targets.",
                  "type": "string"
                },
                "key_ref": {
                  "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                  "type": "string"
                },
                "max_version": {
                  "description": "Maximum TLS version.",
                  "type": "integer"
                },
                "min_version": {
                  "description": "Minimum TLS version.",
                  "type": "integer"
                },
                "server_name": {
                  "description": "Used to verify the hostname for the targets.",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "type": "object"
        },
        "http_sd_config": {
          "properties": {
            "httpclientconfig": {
              "properties": {
                "authorization": {
                  "description": "The HTTP authorization credentials for the targets.",
                  "properties": {
                    "credentials": {
                      "type": "string"
                    },
                    "credentials_file": {
                      "type": "string"
                    },
                    "credentials_ref": {
                      "description": "CredentialsRef is the name of the secret within the secret manager to use as credentials.",
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "basic_auth": {
                  "description": "The HTTP basic authentication credentials for the targets.",
                  "properties": {
                    "password": {
                      "type": "string"
                    },
                    "password_file": {
                      "type": "string"
                    },
                    "password_ref": {
                      "description": "PasswordRef is the name of the secret within the secret manager to use as the password.",
                      "type": "string"
                    },
                    "username": {
                      "type": "string"
                    },
                    "username_file": {
                      "type": "string"
                    },
                    "username_ref": {
                      "description": "UsernameRef is the name of the secret within the secret manager to use as the username.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "bearer_token": {
                  "deprecated": true,
                  "description": "The bearer token for the targets. Deprecated in favour of Authorization.Credentials.",
                  "type": "string"
                },
                "bearer_token_file": {
                  "deprecated": true,
                  "description": "The bearer token file for the targets. Deprecated in favour of Authorization.CredentialsFile.",
                  "type": "string"
                },
                "enable_http2": {
                  "description": "EnableHTTP2 specifies whether the client should configure HTTP2. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.",
                  "type": "boolean"
                },
                "follow_redirects": {
                  "description": "FollowRedirects specifies whether the client should follow HTTP 3xx redirects. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.",
                  "type": "boolean"
                },
                "http_headers": {
                  "description": "HTTPHeaders specify headers to inject in the requests. Those headers could be marshalled back to the users.",
                  "properties": {
                    "headers": {
                      "additionalProperties": {
                        "properties": {
                          "files": {
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "secrets": {
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "values": {
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          }
                        },
                        "type": "object"
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                },
                "no_proxy": {
                  "description": "NoProxy contains addresses that should not use a proxy.",
                  "type": "string"
                },
                "oauth2": {
                  "description": "The OAuth2 client credentials used to fetch a token for the targets.",
                  "properties": {
                    "audience": {
                      "description": "Audience optionally specifies the intended audience of the request.  If empty, the value of TokenURL is used as the intended audience. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                      "type": "string"
                    },
                    "claims": {
                      "additionalProperties": {
                        "additionalProperties": true,
                        "type": "object"
                      },
                      "description": "Claims is a map of claims to be added to the JWT token. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                      "type": "object"
                    },
                    "client_certificate_key": {
                      "type": "string"
                    },
                    "client_certificate_key_file": {
                      "type": "string"
                    },
                    "client_certificate_key_id": {
                      "type": "string"
                    },
                    "client_certificate_key_ref": {
                      "description": "ClientCertificateKeyRef is the name of the secret within the secret manager to use as the client secret.",
                      "type": "string"
                    },
                    "client_id": {
                      "type": "string"
                    },
                    "client_secret": {
                      "type": "string"
                    },
                    "client_secret_file": {
                      "type": "string"
                    },
                    "client_secret_ref": {
                      "description": "ClientSecretRef is the name of the secret within the secret manager to use as the client secret.",
                      "type": "string"
                    },
                    "endpoint_params": {
                      "additionalProperties": {
                        "type": "string"
                      },
                      "type": "object"
                    },
                    "grant_type": {
                      "description": "GrantType is the OAuth2 grant type to use. It can be one of \"client_credentials\" or \"urn:ietf:params:oauth:grant-type:jwt-bearer\" (RFC 7523). Default value is \"client_credentials\"",
                      "type": "string"
                    },
                    "iss": {
                      "description": "Iss is the OAuth client identifier used when communicating with the configured OAuth provider. Default value is client_id. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\".",
                      "type": "string"
                    },
                    "no_proxy": {
                      "description": "NoProxy contains addresses that should not use a proxy.",
                      "type": "string"
                    },
                    "proxy_connect_header": {
                      "additionalProperties": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      },
                      "description": "ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. Assume that at least _some_ of these headers are going to contain secrets and use Secret as the value type instead of string.",
                      "type": "object"
                    },
                    "proxy_from_environment": {
                      "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.",
                      "type": "boolean"
                    },
                    "proxy_url": {
                      "description": "HTTP proxy server to use to connect to the targets.",
                      "properties": {
                        "forcequery": {
                          "description": "append a query ('?') even if RawQuery is empty",
                          "type": "boolean"
                        },
                        "fragment": {
                          "description": "fragment for references, without '#'",
                          "type": "string"
                        },
                        "host": {
                          "description": "host or host:port (see Hostname and Port methods)",
                          "type": "string"
                        },
                        "omithost": {
                          "description": "do not emit empty host (authority)",
                          "type": "boolean"
                        },
                        "opaque": {
                          "description": "encoded opaque data",
                          "type": "string"
                        },
                        "path": {
                          "description": "path (relative paths may omit leading slash)",
                          "type": "string"
                        },
                        "rawfragment": {
                          "description": "encoded fragment hint (see EscapedFragment method)",
                          "type": "string"
                        },
                        "rawpath": {
                          "description": "encoded path hint (see EscapedPath method)",
                          "type": "string"
                        },
                        "rawquery": {
                          "description": "encoded query values, without '?'",
                          "type": "string"
                        },
                        "scheme": {
                          "type": "string"
                        },
                        "user": {
                          "description": "username and password information",
                          "type": "object"
                        }
                      },
                      "type": "object"
                    },
                    "scopes": {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "signature_algorithm": {
                      "description": "SignatureAlgorithm is the RSA algorithm used to sign JWT token. Only used if GrantType is set to \"urn:ietf:params:oauth:grant-type:jwt-bearer\". Default value is RS256 and valid values RS256, RS384, RS512",
                      "type": "string"
                    },
                    "tlsconfig": {
                      "properties": {
                        "ca": {
                          "description": "Text of the CA cert to use for the targets.",
                          "type": "string"
                        },
                        "ca_file": {
                          "description": "The CA cert to use for the targets.",
                          "type": "string"
                        },
                        "ca_ref": {
                          "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                          "type": "string"
                        },
                        "cert": {
                          "description": "Text of the client cert file for the targets.",
                          "type": "string"
                        },
                        "cert_file": {
                          "description": "The client cert file for the targets.",
                          "type": "string"
                        },
                        "cert_ref": {
                          "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                          "type": "string"
                        },
                        "insecure_skip_verify": {
                          "description": "Disable target certificate validation.",
                          "type": "boolean"
                        },
                        "key": {
                          "description": "Text of the client key file for the targets.",
                          "type": "string"
                        },
                        "key_file": {
                          "description": "The client key file for the targets.",
                          "type": "string"
                        },
                        "key_ref": {
                          "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                          "type": "string"
                        },
                        "max_version": {
                          "description": "Maximum TLS version.",
                          "type": "integer"
                        },
                        "min_version": {
                          "description": "Minimum TLS version.",
                          "type": "integer"
                        },
                        "server_name": {
                          "description": "Used to verify the hostname for the targets.",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "token_url": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "proxy_connect_header": {
                  "additionalProperties": {
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "description": "ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. Assume that at least _some_ of these headers are going to contain secrets and use Secret as the value type instead of string.",
                  "type": "object"
                },
                "proxy_from_environment": {
                  "description": "ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.",
                  "type": "boolean"
                },
                "proxy_url": {
                  "description": "HTTP proxy server to use to connect to the targets.",
                  "properties": {
                    "forcequery": {
                      "description": "append a query ('?') even if RawQuery is empty",
                      "type": "boolean"
                    },
                    "fragment": {
                      "description": "fragment for references, without '#'",
                      "type": "string"
                    },
                    "host": {
                      "description": "host or host:port (see Hostname and Port methods)",
                      "type": "string"
                    },
                    "omithost": {
                      "description": "do not emit empty host (authority)",
                      "type": "boolean"
                    },
                    "opaque": {
                      "description": "encoded opaque data",
                      "type": "string"
                    },
                    "path": {
                      "description": "path (relative paths may omit leading slash)",
                      "type": "string"
                    },
                    "rawfragment": {
                      "description": "encoded fragment hint (see EscapedFragment method)",
                      "type": "string"
                    },
                    "rawpath": {
                      "description": "encoded path hint (see EscapedPath method)",
                      "type": "string"
                    },
                    "rawquery": {
                      "description": "encoded query values, without '?'",
                      "type": "string"
                    },
                    "scheme": {
                      "type": "string"
                    },
                    "user": {
                      "description": "username and password information",
                      "type": "object"
                    }
                  },
                  "type": "object"
                },
                "tls_config": {
                  "description": "TLSConfig to use to connect to the targets.",
                  "properties": {
                    "ca": {
                      "description": "Text of the CA cert to use for the targets.",
                      "type": "string"
                    },
                    "ca_file": {
                      "description": "The CA cert to use for the targets.",
                      "type": "string"
                    },
                    "ca_ref": {
                      "description": "CARef is the name of the secret within the secret manager to use as the CA cert for the targets.",
                      "type": "string"
                    },
                    "cert": {
                      "description": "Text of the client cert file for the targets.",
                      "type": "string"
                    },
                    "cert_file": {
                      "description": "The client cert file for the targets.",
                      "type": "string"
                    },
                    "cert_ref": {
                      "description": "CertRef is the name of the secret within the secret manager to use as the client cert for the targets.",
                      "type": "string"
                    },
                    "insecure_skip_verify": {
                      "description": "Disable target certificate validation.",
                      "type": "boolean"
                    },
                    "key": {
                      "description": "Text of the client key file for the targets.",
                      "type": "string"
                    },
                    "key_file": {
                      "description": "The client key file for the targets.",
                      "type": "string"
                    },
                    "key_ref": {
                      "description": "KeyRef is the name of the secret within the secret manager to use as the client key for the targets.",
                      "type": "string"
                    },
                    "max_version": {
                      "description": "Maximum TLS version.",
                      "type": "integer"
                    },
                    "min_version": {
                      "description": "Minimum TLS version.",
                      "type": "integer"
                    },
                    "server_name": {
                      "description": "Used to verify the hostname for the targets.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              },
              "type": "object"
            },
            "refreshinterval": {
              "type": "integer"
            },
            "url": {
              "type": "string"
            }
          },
          "type": "object"
        },
        "idle_conn_timeout": {
          "description": "IdleConnTimeout is the maximum amount of time a connection will remain open before closing itself. By default, it is set to 90 seconds.",
          "pattern": "^[0-9]+(ns|us|µs|ms|s|m|h)$",
          "type": "string"
        },
        "interval": {
          "description": "Duration string (e.g., '1s', '5m', '1h')",
          "pattern": "^[0-9]+(ns|us|µs|ms|s|m|h)$",
          "type": "string"
        },
        "max_conns_per_host": {
          "description": "MaxConnsPerHost limits the total number of connections per host, including connections in the dialing, active, and idle states. Default is 0 (unlimited).",
          "type": "integer"
        },
        "max_idle_conns": {
          "description": "MaxIdleConns is used to set a limit to the maximum idle HTTP connections the client can keep open. By default, it is set to 100. Zero means no limit.",
          "type": "integer"
        },
        "max_idle_conns_per_host": {
          "description": "MaxIdleConnsPerHost is used to set a limit to the maximum idle HTTP connections the host can keep open. If zero, [net/http.DefaultMaxIdleConnsPerHost] is used.",
          "type": "integer"
        },
        "middlewares": {
          "description": "Middlewares are used to add custom functionality to the HTTP client. Middleware handlers are called in the order they appear in this list, with the first middleware becoming the outermost handler.",
          "items": {
            "properties": {
              "id": {
                "description": "ID specifies the name of the extension to use.",
                "type": "object"
              }
            },
            "type": "object"
          },
          "type": "array"
        },
        "proxy_url": {
          "description": "ProxyURL setting for the collector",
          "type": "string"
        },
        "read_buffer_size": {
          "description": "ReadBufferSize for HTTP client. See http.Transport.ReadBufferSize. Default is 0.",
          "type": "integer"
        },
        "timeout": {
          "description": "Timeout parameter configures `http.Client.Timeout`. Default is 0 (unlimited).",
          "pattern": "^[0-9]+(ns|us|µs|ms|s|m|h)$",
          "type": "string"
        },
        "tls": {
          "description": "TLS struct exposes TLS client configuration.",
          "properties": {
            "ca_file": {
              "description": "Path to the CA cert. For a client this verifies the server certificate. For a server this verifies client certificates. If empty uses system root CA. (optional)",
              "type": "string"
            },
            "ca_pem": {
              "description": "In memory PEM encoded cert. (optional)",
              "type": "string"
            },
            "cert_file": {
              "description": "Path to the TLS cert to use for TLS required connections. (optional)",
              "type": "string"
            },
            "cert_pem": {
              "description": "In memory PEM encoded TLS cert to use for TLS required connections. (optional)",
              "type": "string"
            },
            "cipher_suites": {
              "description": "CipherSuites is a list of TLS cipher suites that the TLS transport can use. If left blank, a safe default list is used. See https://go.dev/src/crypto/tls/cipher_suites.go for a list of supported cipher suites.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "curve_preferences": {
              "description": "contains the elliptic curves that will be used in an ECDHE handshake, in preference order Defaults to empty list and \"crypto/tls\" defaults are used, internally.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "include_system_ca_certs_pool": {
              "description": "If true, load system CA certificates pool in addition to the certificates configured in this struct.",
              "type": "boolean"
            },
            "insecure": {
              "description": "In gRPC and HTTP when set to true, this is used to disable the client transport security. See https://godoc.org/google.golang.org/grpc#WithInsecure for gRPC. Please refer to https://godoc.org/crypto/tls#Config for more information. (optional, default false)",
              "type": "boolean"
            },
            "insecure_skip_verify": {
              "description": "InsecureSkipVerify will enable TLS but not verify the certificate.",
              "type": "boolean"
            },
            "key_file": {
              "description": "Path to the TLS key to use for TLS required connections. (optional)",
              "type": "string"
            },
            "key_pem": {
              "description": "In memory PEM encoded TLS key to use for TLS required connections. (optional)",
              "type": "string"
            },
            "max_version": {
              "description": "MaxVersion sets the maximum TLS version that is acceptable. If not set, refer to crypto/tls for defaults. (optional)",
              "type": "string"
            },
            "min_version": {
              "description": "MinVersion sets the minimum TLS version that is acceptable. If not set, TLS 1.2 will be used. (optional)",
              "type": "string"
            },
            "reload_interval": {
              "description": "ReloadInterval specifies the duration after which the certificate will be reloaded If not set, it will never be reloaded (optional)",
              "pattern": "^[0-9]+(ns|us|µs|ms|s|m|h)$",
              "type": "string"
            },
            "server_name_override": {
              "description": "ServerName requested by client for virtual hosting. This sets the ServerName in the TLSConfig. Please refer to https://godoc.org/crypto/tls#Config for more information. (optional)",
              "type": "string"
            },
            "tpm": {
              "description": "Trusted platform module configuration",
              "properties": {
                "auth": {
                  "type": "string"
                },
                "enabled": {
                  "type": "boolean"
                },
                "owner_auth": {
                  "type": "string"
                },
                "path": {
                  "description": "The path to the TPM device or Unix domain socket. For instance /dev/tpm0 or /dev/tpmrm0.",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "type": "object"
        },
        "write_buffer_size": {
          "description": "WriteBufferSize for HTTP client. See http.Transport.WriteBufferSize. Default is 0.",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "trim_metric_suffixes": {
      "type": "boolean"
    },
    "use_start_time_metric": {
      "description": "UseStartTimeMetric enables retrieving the start time of all counter metrics from the process_start_time_seconds metric. This is only correct if all counters on that endpoint started after the process start time, and the process is the only actor exporting the metric after the process started. It should not be used in \"exporters\" which export counters that may have started before the process itself. Use only if you know what you are doing, as this may result in incorrect rate calculations.",
      "type": "boolean"
    }
  },
  "type": "object"
}